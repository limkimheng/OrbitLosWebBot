import { Signal } from '@telegram-apps/signals';
import { CancelablePromise, If, TypedError } from '@telegram-apps/bridge';
import { AnyFn } from '../types.js';
type Signalified<Fn extends AnyFn, Cancelable extends boolean> = (...args: Parameters<Fn>) => If<Cancelable, CancelablePromise<ReturnType<Fn>>, PromiseLike<ReturnType<Fn>>>;
/**
 * Function doing the following:
 * 1. Prevents the wrapped function from being called concurrently.
 * 2. Being called, updates the passed promise and error signals.
 *
 * As a result, the function returns a new one, returning a cancelable promise.
 * @param fn - function to wrap.
 * @param createPendingError - function that creates error in case of concurrent call
 * @param promise - signal containing the execution promise
 * @param error - signal containing the last call error.
 * @param cancelable - is result cancelable. True by default.
 */
export declare function signalifyAsyncFn<Fn extends AnyFn>(fn: Fn, createPendingError: () => TypedError<any>, promise: Signal<CancelablePromise<Awaited<ReturnType<Fn>>> | undefined>, error: Signal<Error | undefined>, cancelable?: true): Signalified<Fn, true>;
/**
 * Function doing the following:
 * 1. Prevents the wrapped function from being called concurrently.
 * 2. Being called, updates the passed promise and error signals.
 *
 * As a result, the function returns a new one, returning a non-cancelable promise.
 * @param fn - function to wrap.
 * @param createPendingError - function that creates error in case of concurrent call
 * @param promise - signal containing the execution promise
 * @param error - signal containing the last call error.
 * @param cancelable - is result cancelable. True by default.
 */
export declare function signalifyAsyncFn<Fn extends AnyFn>(fn: Fn, createPendingError: () => TypedError<any>, promise: Signal<Promise<Awaited<ReturnType<Fn>>> | undefined>, error: Signal<Error | undefined>, cancelable: false): Signalified<Fn, false>;
export {};
