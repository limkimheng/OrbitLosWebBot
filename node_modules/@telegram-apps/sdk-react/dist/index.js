import { useMemo as Co, useSyncExternalStore as Ro } from "react";
class H extends Error {
  constructor(t, n, r) {
    super(
      typeof n == "object" ? n.message : n || t,
      {
        cause: typeof n == "object" ? n.cause : r
      }
    ), this.type = t, Object.setPrototypeOf(this, H.prototype);
  }
}
function Hn(e) {
  return e.replace(/[A-Z]/g, (t) => `_${t.toLowerCase()}`);
}
function Bo(e) {
  return e.replace(/_[a-z]/g, (t) => t[1].toUpperCase());
}
const Po = "ERR_INVALID_VALUE", To = "ERR_UNEXPECTED_VALUE", Io = "ERR_UNEXPECTED_TYPE", zn = "ERR_PARSE";
function Gn(e, t) {
  const n = {};
  for (const r in e) {
    const o = e[r];
    if (!o)
      continue;
    let s, a;
    typeof o == "function" ? (s = r, a = o) : [s, a] = o;
    try {
      const i = a(t(s));
      i !== void 0 && (n[r] = i);
    } catch (i) {
      throw new H(
        zn,
        `Parser for "${r}" property failed${s === r ? "" : `. Source field: "${s}"`}`,
        i
      );
    }
  }
  return n;
}
function Jn(e) {
  let t = e;
  if (typeof t == "string")
    try {
      t = JSON.parse(t);
    } catch (n) {
      throw new H(Po, { cause: n });
    }
  if (typeof t != "object" || !t || Array.isArray(t))
    throw new H(To);
  return t;
}
function q(e, t) {
  return (n) => {
    const r = (o) => {
      if (!(n && o === void 0))
        try {
          return t(o);
        } catch (s) {
          throw new H(zn, {
            message: `"${e}" transformer failed to parse the value`,
            cause: s
          });
        }
    };
    return /* @__PURE__ */ Object.assign(
      r,
      {
        isValid(o) {
          try {
            return r(o), !0;
          } catch {
            return !1;
          }
        }
      }
    );
  };
}
function Ne(e, t) {
  return q(t || "object", (n) => {
    const r = Jn(n);
    return Gn(e, (o) => r[o]);
  });
}
function Ce(e) {
  throw new H(Io, `Unexpected value received: ${JSON.stringify(e)}`);
}
const ko = q("boolean", (e) => {
  if (typeof e == "boolean")
    return e;
  const t = String(e);
  if (t === "1" || t === "true")
    return !0;
  if (t === "0" || t === "false")
    return !1;
  Ce(e);
}), N = q("string", (e) => {
  if (typeof e == "string" || typeof e == "number")
    return e.toString();
  Ce(e);
}), qe = q("number", (e) => {
  if (typeof e == "number")
    return e;
  if (typeof e == "string") {
    const t = Number(e);
    if (!Number.isNaN(t))
      return t;
  }
  Ce(e);
}), Ot = q("date", (e) => e instanceof Date ? e : new Date(qe()(e) * 1e3));
function Yn(e, t) {
  return q(t || "searchParams", (n) => {
    typeof n != "string" && !(n instanceof URLSearchParams) && Ce(n);
    const r = typeof n == "string" ? new URLSearchParams(n) : n;
    return Gn(e, (o) => {
      const s = r.get(o);
      return s === null ? void 0 : s;
    });
  });
}
function dt(e) {
  for (const t in e)
    e[t] = [Hn(t), e[t]];
  return e;
}
const Oo = (e) => {
  const t = qe(), n = qe(!0), r = N(), o = N(!0), s = ko(!0), a = Ne(dt({
    addedToAttachmentMenu: s,
    allowsWriteToPm: s,
    firstName: r,
    id: t,
    isBot: s,
    isPremium: s,
    languageCode: o,
    lastName: o,
    photoUrl: o,
    username: o
  }), "User")(!0);
  return Yn(
    dt({
      authDate: Ot(),
      canSendAfter: n,
      chat: Ne(
        dt({
          id: t,
          type: r,
          title: r,
          photoUrl: o,
          username: o
        }),
        "Chat"
      )(!0),
      chatInstance: o,
      chatType: o,
      hash: r,
      queryId: o,
      receiver: a,
      startParam: o,
      signature: r,
      user: a
    }),
    "initData"
  )(e);
};
function de(e) {
  return /^#[\da-f]{6}$/i.test(e);
}
function Do(e) {
  return /^#[\da-f]{3}$/i.test(e);
}
function Qn(e) {
  const t = e.replace(/\s/g, "").toLowerCase();
  if (de(t))
    return t;
  if (Do(t)) {
    let r = "#";
    for (let o = 0; o < 3; o += 1)
      r += t[1 + o].repeat(2);
    return r;
  }
  const n = t.match(/^rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)$/) || t.match(/^rgba\((\d{1,3}),(\d{1,3}),(\d{1,3}),\d{1,3}\)$/);
  if (!n)
    throw new Error(`Value "${e}" does not satisfy any of known RGB formats.`);
  return n.slice(1).reduce((r, o) => {
    const s = parseInt(o, 10).toString(16);
    return r + (s.length === 1 ? "0" : "") + s;
  }, "#");
}
const xo = q("rgb", (e) => Qn(N()(e))), Mo = q(
  "themeParams",
  (e) => {
    const t = xo(!0);
    return Object.entries(Jn(e)).reduce((n, [r, o]) => (n[Bo(r)] = t(o), n), {});
  }
);
// @__NO_SIDE_EFFECTS__
function vn(e) {
  return JSON.stringify(
    Object.fromEntries(
      Object.entries(e).map(([t, n]) => [Hn(t), n])
    )
  );
}
// @__NO_SIDE_EFFECTS__
function Tc(e) {
  const {
    initDataRaw: t,
    startParam: n,
    showSettings: r,
    botInline: o,
    fullscreen: s,
    defaultColors: a
  } = e, i = new URLSearchParams();
  return i.set("tgWebAppPlatform", e.platform), i.set("tgWebAppThemeParams", /* @__PURE__ */ vn(e.themeParams)), i.set("tgWebAppVersion", e.version), t && i.set("tgWebAppData", t), n && i.set("tgWebAppStartParam", n), typeof r == "boolean" && i.set("tgWebAppShowSettings", r ? "1" : "0"), typeof o == "boolean" && i.set("tgWebAppBotInline", o ? "1" : "0"), typeof s == "boolean" && i.set("tgWebAppFullscreen", s ? "1" : "0"), a && i.set("tgWebAppDefaultColors", /* @__PURE__ */ vn(a)), i.toString();
}
function jo(e, t) {
  return q("array", (n) => {
    let r;
    if (Array.isArray(n))
      r = n;
    else if (typeof n == "string")
      try {
        const o = JSON.parse(n);
        Array.isArray(o) && (r = o);
      } catch {
      }
    return r || Ce(n), r.map(e);
  });
}
function Kn(e) {
  return !!e && typeof e == "object" && !Array.isArray(e);
}
function wt(...e) {
  return e.map((t) => {
    if (typeof t == "string")
      return t;
    if (Kn(t))
      return wt(Object.entries(t).map((n) => n[1] && n[0]));
    if (Array.isArray(t))
      return wt(...t);
  }).filter(Boolean).join(" ");
}
function Ic(...e) {
  return e.reduce((t, n) => (Kn(n) && Object.entries(n).forEach(([r, o]) => {
    const s = wt(t[r], o);
    s && (t[r] = s);
  }), t), {});
}
class z extends Error {
  constructor(t, n, r) {
    super(
      typeof n == "object" ? n.message : n || t,
      {
        cause: typeof n == "object" ? n.cause : r
      }
    ), this.type = t, Object.setPrototypeOf(this, z.prototype);
  }
}
function Zn(e) {
  return e.replace(/[A-Z]/g, (t) => `_${t.toLowerCase()}`);
}
function Lo(e) {
  return e.replace(/_[a-z]/g, (t) => t[1].toUpperCase());
}
const Vo = "ERR_INVALID_VALUE", No = "ERR_UNEXPECTED_VALUE", qo = "ERR_UNEXPECTED_TYPE", Xn = "ERR_PARSE";
function er(e, t) {
  const n = {};
  for (const r in e) {
    const o = e[r];
    if (!o)
      continue;
    let s, a;
    typeof o == "function" ? (s = r, a = o) : [s, a] = o;
    try {
      const i = a(t(s));
      i !== void 0 && (n[r] = i);
    } catch (i) {
      throw new z(
        Xn,
        `Parser for "${r}" property failed${s === r ? "" : `. Source field: "${s}"`}`,
        i
      );
    }
  }
  return n;
}
function tr(e) {
  let t = e;
  if (typeof t == "string")
    try {
      t = JSON.parse(t);
    } catch (n) {
      throw new z(Vo, { cause: n });
    }
  if (typeof t != "object" || !t || Array.isArray(t))
    throw new z(No);
  return t;
}
function D(e, t) {
  return (n) => {
    const r = (o) => {
      if (!(n && o === void 0))
        try {
          return t(o);
        } catch (s) {
          throw new z(Xn, {
            message: `"${e}" transformer failed to parse the value`,
            cause: s
          });
        }
    };
    return /* @__PURE__ */ Object.assign(
      r,
      {
        isValid(o) {
          try {
            return r(o), !0;
          } catch {
            return !1;
          }
        }
      }
    );
  };
}
function k(e, t) {
  return D(t || "object", (n) => {
    const r = tr(n);
    return er(e, (o) => r[o]);
  });
}
function Re(e) {
  throw new z(qo, `Unexpected value received: ${JSON.stringify(e)}`);
}
const $e = D("boolean", (e) => {
  if (typeof e == "boolean")
    return e;
  const t = String(e);
  if (t === "1" || t === "true")
    return !0;
  if (t === "0" || t === "false")
    return !1;
  Re(e);
}), B = D("string", (e) => {
  if (typeof e == "string" || typeof e == "number")
    return e.toString();
  Re(e);
}), fe = D("number", (e) => {
  if (typeof e == "number")
    return e;
  if (typeof e == "string") {
    const t = Number(e);
    if (!Number.isNaN(t))
      return t;
  }
  Re(e);
}), $o = D("date", (e) => e instanceof Date ? e : new Date(fe()(e) * 1e3));
function nr(e, t) {
  return D(t || "searchParams", (n) => {
    typeof n != "string" && !(n instanceof URLSearchParams) && Re(n);
    const r = typeof n == "string" ? new URLSearchParams(n) : n;
    return er(e, (o) => {
      const s = r.get(o);
      return s === null ? void 0 : s;
    });
  });
}
function ft(e) {
  for (const t in e)
    e[t] = [Zn(t), e[t]];
  return e;
}
const Uo = (e) => {
  const t = fe(), n = fe(!0), r = B(), o = B(!0), s = $e(!0), a = k(ft({
    addedToAttachmentMenu: s,
    allowsWriteToPm: s,
    firstName: r,
    id: t,
    isBot: s,
    isPremium: s,
    languageCode: o,
    lastName: o,
    photoUrl: o,
    username: o
  }), "User")(!0);
  return nr(
    ft({
      authDate: $o(),
      canSendAfter: n,
      chat: k(
        ft({
          id: t,
          type: r,
          title: r,
          photoUrl: o,
          username: o
        }),
        "Chat"
      )(!0),
      chatInstance: o,
      chatType: o,
      hash: r,
      queryId: o,
      receiver: a,
      startParam: o,
      signature: r,
      user: a
    }),
    "initData"
  )(e);
};
function Fo(e) {
  return /^#[\da-f]{6}$/i.test(e);
}
function Wo(e) {
  return /^#[\da-f]{3}$/i.test(e);
}
function Ho(e) {
  const t = e.replace(/\s/g, "").toLowerCase();
  if (Fo(t))
    return t;
  if (Wo(t)) {
    let r = "#";
    for (let o = 0; o < 3; o += 1)
      r += t[1 + o].repeat(2);
    return r;
  }
  const n = t.match(/^rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)$/) || t.match(/^rgba\((\d{1,3}),(\d{1,3}),(\d{1,3}),\d{1,3}\)$/);
  if (!n)
    throw new Error(`Value "${e}" does not satisfy any of known RGB formats.`);
  return n.slice(1).reduce((r, o) => {
    const s = parseInt(o, 10).toString(16);
    return r + (s.length === 1 ? "0" : "") + s;
  }, "#");
}
const zo = D("rgb", (e) => Ho(B()(e))), An = D(
  "themeParams",
  (e) => {
    const t = zo(!0);
    return Object.entries(tr(e)).reduce((n, [r, o]) => (n[Lo(r)] = t(o), n), {});
  }
);
// @__NO_SIDE_EFFECTS__
function yt(e) {
  return JSON.stringify(
    Object.fromEntries(
      Object.entries(e).map(([t, n]) => [Zn(t), n])
    )
  );
}
const Go = (e) => {
  const t = B(), n = B(!0), r = $e(!0);
  return nr({
    botInline: ["tgWebAppBotInline", r],
    defaultColors: ["tgWebAppDefaultColors", An(!0)],
    fullscreen: ["tgWebAppFullscreen", r],
    initData: ["tgWebAppData", Uo(!0)],
    initDataRaw: ["tgWebAppData", n],
    platform: ["tgWebAppPlatform", t],
    showSettings: ["tgWebAppShowSettings", r],
    startParam: ["tgWebAppStartParam", n],
    themeParams: ["tgWebAppThemeParams", An()],
    version: ["tgWebAppVersion", t]
  }, "launchParams")(e);
};
// @__NO_SIDE_EFFECTS__
function Jo(e) {
  const {
    initDataRaw: t,
    startParam: n,
    showSettings: r,
    botInline: o,
    fullscreen: s,
    defaultColors: a
  } = e, i = new URLSearchParams();
  return i.set("tgWebAppPlatform", e.platform), i.set("tgWebAppThemeParams", /* @__PURE__ */ yt(e.themeParams)), i.set("tgWebAppVersion", e.version), t && i.set("tgWebAppData", t), n && i.set("tgWebAppStartParam", n), typeof r == "boolean" && i.set("tgWebAppShowSettings", r ? "1" : "0"), typeof o == "boolean" && i.set("tgWebAppBotInline", o ? "1" : "0"), typeof s == "boolean" && i.set("tgWebAppFullscreen", s ? "1" : "0"), a && i.set("tgWebAppDefaultColors", /* @__PURE__ */ yt(a)), i.toString();
}
const rr = k({
  eventType: B(),
  eventData: (e) => e
}, "miniAppsMessage"), or = D("fn", (e) => {
  if (typeof e == "function")
    return e;
  Re(e);
});
function Yo(e) {
  return !!e && typeof e == "object" && !Array.isArray(e);
}
const Qo = k({
  TelegramWebviewProxy: k({ postEvent: or() })()
});
function sr(e) {
  return Qo().isValid(e);
}
function Ko() {
  try {
    return window.self !== window.top;
  } catch {
    return !0;
  }
}
var Zo = Object.defineProperty, Xo = (e, t, n) => t in e ? Zo(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, ar = (e, t, n) => Xo(e, typeof t != "symbol" ? t + "" : t, n);
let p = class ir extends Error {
  constructor(t, n, r) {
    super(
      typeof n == "object" ? n.message : n || t,
      {
        cause: typeof n == "object" ? n.cause : r
      }
    ), this.type = t, Object.setPrototypeOf(this, ir.prototype);
  }
};
function cr(e, t, n) {
  return e.addEventListener(t, n), () => e.removeEventListener(t, n);
}
function ne(...e) {
  const t = e.flat(1);
  return [
    t.push.bind(t),
    () => {
      t.forEach((n) => {
        n();
      });
    }
  ];
}
function es(e, t) {
  return e instanceof p && e.type === t;
}
function Dt(e) {
  return (t) => es(t, e);
}
const ur = "ERR_ABORTED", pr = "ERR_CANCELED", lr = "ERR_TIMED_OUT";
function Cn(e) {
  return new p(ur, { cause: e });
}
const kc = Dt(lr), Oc = Dt(ur), Dc = Dt(pr);
function Rn(e, t) {
  return e.reject = t.reject, e;
}
class h extends Promise {
  constructor(t, n) {
    let r, o;
    typeof t == "function" ? (r = t, o = n) : o = t;
    let s, a;
    super((i, l) => {
      o || (o = {});
      const { abortSignal: u } = o;
      if (u && u.aborted)
        return l(Cn(u.reason));
      const [_, g] = ne(), y = (m) => (...W) => (g(), m(...W)), L = new AbortController(), { signal: C } = L;
      a = y((m) => {
        L.abort(m), l(m);
      }), s = y(i), u && _(
        cr(u, "abort", () => {
          a(Cn(u.reason));
        })
      );
      const { timeout: b } = o;
      if (b) {
        const m = setTimeout(() => {
          a(new p(lr, `Timeout reached: ${b}ms`));
        }, b);
        _(() => {
          clearTimeout(m);
        });
      }
      r && r(s, a, C);
    }), ar(this, "reject"), this.reject = a;
  }
  /**
   * Creates a new BetterPromise instance using executor, resolving promise when a result
   * was returned.
   * @param fn - function returning promise result.
   * @param options - additional options.
   */
  static withFn(t, n) {
    return new h((r, o, s) => {
      try {
        const a = t(s);
        return a instanceof Promise ? a.then(r, o) : r(a);
      } catch (a) {
        o(a);
      }
    }, n);
  }
  /**
   * @see Promise.resolve
   */
  static resolve(t) {
    return new h((n) => {
      n(t);
    });
  }
  /**
   * @see Promise.reject
   */
  static reject(t) {
    return new h((n, r) => {
      r(t);
    });
  }
  /**
   * Cancels the promise execution.
   */
  cancel() {
    this.reject(new p(pr));
  }
  /**
   * @see Promise.catch
   */
  catch(t) {
    return this.then(void 0, t);
  }
  /**
   * @see Promise.finally
   */
  finally(t) {
    return Rn(super.finally(t), this);
  }
  /**
   * @see Promise.then
   */
  then(t, n) {
    return Rn(super.then(t, n), this);
  }
}
function Bn(e, t) {
  return e.resolve = t.resolve, e;
}
let ts = class Ie extends h {
  constructor(t, n) {
    let r, o;
    typeof t == "function" ? (r = t, o = n) : o = t;
    let s;
    super((a, i, l) => {
      s = a, r && r(a, i, l);
    }, o), ar(this, "resolve"), this.resolve = s;
  }
  /**
   * Creates a new EnhancedPromise instance using executor, resolving promise when a result
   * was returned.
   * @param fn - function returning promise result.
   * @param options - additional options.
   */
  static withFn(t, n) {
    return new Ie(
      (r, o, s) => h.withFn(t, { abortSignal: s }).then(r, o),
      n
    );
  }
  /**
   * @see Promise.resolve
   */
  static resolve(t) {
    return new Ie((n) => {
      n(t);
    });
  }
  /**
   * @see Promise.reject
   */
  static reject(t) {
    return new Ie((n, r) => {
      r(t);
    });
  }
  /**
   * @see Promise.catch
   */
  catch(t) {
    return this.then(void 0, t);
  }
  /**
   * @see Promise.finally
   */
  finally(t) {
    return Bn(super.finally(t), this);
  }
  /**
   * @see Promise.then
   */
  then(t, n) {
    return Bn(super.then(t, n), this);
  }
};
function ns(e, t) {
  return new h((n) => {
    setTimeout(n, e);
  }, { abortSignal: t });
}
function dr(e) {
  return `tapps/${e}`;
}
function P(e, t) {
  sessionStorage.setItem(dr(e), JSON.stringify(t));
}
function T(e) {
  const t = sessionStorage.getItem(dr(e));
  try {
    return t ? JSON.parse(t) : void 0;
  } catch {
  }
}
function xt(e) {
  return e.replace(/[A-Z]/g, (t) => `-${t.toLowerCase()}`);
}
// @__NO_SIDE_EFFECTS__
function rs(e, t) {
  t || (t = {});
  const {
    textColor: n,
    bgColor: r,
    shouldLog: o = !0
  } = t;
  function s(a, ...i) {
    if (!o || typeof o == "function" && !o())
      return;
    const l = "font-weight:bold;padding:0 5px;border-radius:5px";
    console[a](
      `%c${Intl.DateTimeFormat("en-GB", {
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit",
        fractionalSecondDigits: 3,
        timeZone: "UTC"
      }).format(/* @__PURE__ */ new Date())}%c / %c${e}`,
      `${l};background-color: lightblue;color:black`,
      "",
      `${l};${n ? `color:${n};` : ""}${r ? `background-color:${r}` : ""}`,
      ...i
    );
  }
  return [
    function(...a) {
      s("log", ...a);
    },
    function(...a) {
      s("error", ...a);
    }
  ];
}
function Mt(e, t) {
  document.documentElement.style.setProperty(e, t);
}
function jt(e) {
  document.documentElement.style.removeProperty(e);
}
function os(e, t) {
  t();
}
// @__NO_SIDE_EFFECTS__
function re(e, t) {
  t || (t = {});
  const n = t.equals || Object.is;
  let r = [], o = e;
  const s = (u) => {
    if (!n(o, u)) {
      const _ = o;
      o = u, os(l, () => {
        [...r].forEach(([g, y]) => {
          g(u, _), y && i(g, !0);
        });
      });
    }
  };
  function a(u) {
    const _ = typeof u != "object" ? { once: u } : u;
    return {
      once: _.once || !1,
      signal: _.signal || !1
    };
  }
  const i = (u, _) => {
    const g = a(_), y = r.findIndex(([L, C]) => L === u && C.once === g.once && C.signal === g.signal);
    y >= 0 && r.splice(y, 1);
  }, l = Object.assign(
    function() {
      return ss(l), o;
    },
    {
      destroy() {
        r = [];
      },
      set: s,
      reset() {
        s(e);
      },
      sub(u, _) {
        return r.push([u, a(_)]), () => i(u, _);
      },
      unsub: i,
      unsubAll() {
        r = r.filter((u) => u[1].signal);
      }
    }
  );
  return l;
}
const _t = [];
function ss(e) {
  _t.length && _t[_t.length - 1].add(e);
}
const as = /* @__PURE__ */ re(!1), [Lt, is] = /* @__PURE__ */ rs("Bridge", {
  bgColor: "#9147ff",
  textColor: "white",
  shouldLog: as
}), cs = {
  clipboard_text_received: k({
    req_id: B(),
    data: (e) => e === null ? e : B(!0)(e)
  }, "clipboard_text_received"),
  custom_method_invoked: k({
    req_id: B(),
    result: (e) => e,
    error: B(!0)
  }, "custom_method_invoked"),
  popup_closed: D("popup_closed", (e) => e ? k({
    button_id: (t) => t == null ? void 0 : B()(t)
  })()(e) : {}),
  viewport_changed: k({
    height: fe(),
    width: (e) => e == null ? window.innerWidth : fe()(e),
    is_state_stable: $e(),
    is_expanded: $e()
  }, "viewport_changed")
};
function us(e) {
  const t = window, [, n] = ne(
    // Add listener, which handles events sent from the Telegram web application and also events
    // generated by the local emitEvent function.
    cr(t, "message", (r) => {
      if (r.source !== t.parent)
        return;
      let o;
      try {
        o = rr()(r.data);
      } catch {
        return;
      }
      const { eventType: s, eventData: a } = o, i = cs[s];
      try {
        const l = i ? i()(a) : a;
        Lt("Event received:", l ? { eventType: s, eventData: l } : { eventType: s }), e([s, l]);
      } catch (l) {
        is(
          [
            `An error occurred processing the "${s}" event from the Telegram application.`,
            "Please, file an issue here:",
            "https://github.com/Telegram-Mini-Apps/telegram-apps/issues/new/choose"
          ].join(`
`),
          o,
          l
        );
      }
    })
  );
  return n;
}
const St = /* @__PURE__ */ re(), Pn = /* @__PURE__ */ re();
function fr() {
  return Pn() || Pn.set(us(St.set)), St;
}
const mt = /* @__PURE__ */ re({});
function _r(e) {
  let t = mt()[e];
  return t || (t = /* @__PURE__ */ re(void 0, {
    equals() {
      return !1;
    }
  }), fr().sub((n) => {
    n && n[0] === e && t.set(n[1]);
  }), mt.set({ ...mt(), [e]: t })), t;
}
function S(e, t, n) {
  return _r(e).sub(t, n);
}
const ps = "ERR_METHOD_UNSUPPORTED", ls = "ERR_RETRIEVE_LP_FAILED", ds = "ERR_METHOD_PARAMETER_UNSUPPORTED", mr = "ERR_UNKNOWN_ENV", fs = "ERR_INVOKE_CUSTOM_METHOD_RESPONSE", _s = /* @__PURE__ */ re("https://web.telegram.org");
function Vt(e, t) {
  Lt("Posting event:", t ? { eventType: e, eventData: t } : { eventType: e });
  const n = window;
  if (sr(n)) {
    n.TelegramWebviewProxy.postEvent(e, JSON.stringify(t));
    return;
  }
  const r = JSON.stringify({ eventType: e, eventData: t });
  if (Ko())
    return n.parent.postMessage(r, _s());
  const { external: o } = n;
  if (k({ notify: or() })().isValid(o)) {
    o.notify(r);
    return;
  }
  throw new p(mr);
}
function Nt(e, t, n) {
  n || (n = {});
  const { capture: r } = n, [o, s] = ne();
  return new h((a) => {
    (Array.isArray(t) ? t : [t]).forEach((i) => {
      o(
        S(i, (l) => {
          (!r || (Array.isArray(t) ? r({
            event: i,
            payload: l
          }) : r(l))) && a(l);
        })
      );
    }), (n.postEvent || Vt)(e, n.params);
  }, n).finally(s);
}
function qt(e) {
  return Go()(e);
}
function hr(e) {
  return qt(
    e.replace(/^[^?#]*[?#]/, "").replace(/[?#]/g, "&")
  );
}
function ms() {
  return hr(window.location.href);
}
function hs() {
  const e = performance.getEntriesByType("navigation")[0];
  if (!e)
    throw new Error("Unable to get first navigation entry.");
  return hr(e.name);
}
const bs = "launchParams";
function gs() {
  return qt(T(bs) || "");
}
function br(e) {
  P("launchParams", /* @__PURE__ */ Jo(e));
}
function gr(e) {
  return e instanceof Error ? e.message + (e.cause ? `
  ${gr(e.cause)}` : "") : JSON.stringify(e);
}
function J() {
  const e = [];
  for (const t of [
    // Try to retrieve launch parameters from the current location. This method can return
    // nothing in case, location was changed, and then the page was reloaded.
    ms,
    // Then, try using the lower level API - window.performance.
    hs,
    // Finally, try to extract launch parameters from the session storage.
    gs
  ])
    try {
      const n = t();
      return br(n), n;
    } catch (n) {
      e.push(n);
    }
  throw new p(ls, [
    "Unable to retrieve launch parameters from any known source. Perhaps, you have opened your app outside Telegram?",
    "📖 Refer to docs for more information:",
    "https://docs.telegram-mini-apps.com/packages/telegram-apps-sdk/environment",
    "Collected errors:",
    ...e.map((t) => `— ${gr(t)}`)
  ].join(`
`));
}
function Tn(e) {
  if (e === "simple")
    try {
      return J(), !0;
    } catch {
      return !1;
    }
  return h.withFn(async () => {
    if (sr(window))
      return !0;
    try {
      return await Nt("web_app_request_theme", "theme_changed", { timeout: 100 }), !0;
    } catch {
      return !1;
    }
  }, e);
}
function Et(e, t) {
  window.dispatchEvent(new MessageEvent("message", {
    data: JSON.stringify({ eventType: e, eventData: t }),
    // We specify window.parent to imitate the case, the parent iframe sent us this event.
    source: window.parent
  }));
}
function ws(e, t) {
  if (typeof t == "string")
    try {
      const { eventType: n } = rr()(t);
      n === "web_app_request_theme" && Et("theme_changed", {
        theme_params: JSON.parse(/* @__PURE__ */ yt(e))
      }), n === "web_app_request_viewport" && Et("viewport_changed", {
        width: window.innerWidth,
        height: window.innerHeight,
        is_state_stable: !0,
        is_expanded: !0
      });
    } catch {
    }
}
function xc(e) {
  var t;
  const n = typeof e == "string" ? qt(e) : e;
  br(n);
  const r = (t = window.TelegramWebviewProxy) == null ? void 0 : t.postEvent;
  window.TelegramWebviewProxy = {
    postEvent(o, s) {
      ws(n.themeParams, JSON.stringify({ eventType: o, eventData: s })), r == null || r(o, s);
    }
  }, Lt("Environment was mocked by the mockTelegramEnv function");
}
function ys() {
  [
    ["TelegramGameProxy_receiveEvent"],
    // Windows Phone.
    ["TelegramGameProxy", "receiveEvent"],
    // Desktop.
    ["Telegram", "WebView", "receiveEvent"]
    // Android and iOS.
  ].forEach((e) => {
    let t = window;
    e.forEach((n, r, o) => {
      if (r === o.length - 1) {
        t[n] = Et;
        return;
      }
      n in t || (t[n] = {}), t = t[n];
    });
  });
}
function Ss() {
  ["TelegramGameProxy_receiveEvent", "TelegramGameProxy", "Telegram"].forEach((e) => {
    delete window[e];
  });
}
function O(e, t, n) {
  _r(e).unsub(t, n);
}
function Mc(e, t) {
  return fr().sub(e, t);
}
function jc(e, t) {
  St.unsub(e, t);
}
function wr(e) {
  return ({ req_id: t }) => t === e;
}
function In(e) {
  return e.split(".").map(Number);
}
function Es(e, t) {
  const n = In(e), r = In(t), o = Math.max(n.length, r.length);
  for (let s = 0; s < o; s += 1) {
    const a = n[s] || 0, i = r[s] || 0;
    if (a !== i)
      return a > i ? 1 : -1;
  }
  return 0;
}
function w(e, t) {
  return Es(e, t) <= 0;
}
function G(e, t, n) {
  if (typeof n == "string") {
    if (e === "web_app_open_link") {
      if (t === "try_instant_view")
        return w("6.4", n);
      if (t === "try_browser")
        return w("7.6", n);
    }
    if (e === "web_app_set_header_color" && t === "color")
      return w("6.9", n);
    if (e === "web_app_close" && t === "return_back")
      return w("7.6", n);
    if (e === "web_app_setup_main_button" && t === "has_shine_effect")
      return w("7.10", n);
  }
  switch (e) {
    case "web_app_open_tg_link":
    case "web_app_open_invoice":
    case "web_app_setup_back_button":
    case "web_app_set_background_color":
    case "web_app_set_header_color":
    case "web_app_trigger_haptic_feedback":
      return w("6.1", t);
    case "web_app_open_popup":
      return w("6.2", t);
    case "web_app_close_scan_qr_popup":
    case "web_app_open_scan_qr_popup":
    case "web_app_read_text_from_clipboard":
      return w("6.4", t);
    case "web_app_switch_inline_query":
      return w("6.7", t);
    case "web_app_invoke_custom_method":
    case "web_app_request_write_access":
    case "web_app_request_phone":
      return w("6.9", t);
    case "web_app_setup_settings_button":
      return w("6.10", t);
    case "web_app_biometry_get_info":
    case "web_app_biometry_open_settings":
    case "web_app_biometry_request_access":
    case "web_app_biometry_request_auth":
    case "web_app_biometry_update_token":
      return w("7.2", t);
    case "web_app_setup_swipe_behavior":
      return w("7.7", t);
    case "web_app_share_to_story":
      return w("7.8", t);
    case "web_app_setup_secondary_button":
    case "web_app_set_bottom_bar_color":
      return w("7.10", t);
    case "web_app_request_safe_area":
    case "web_app_request_content_safe_area":
    case "web_app_request_fullscreen":
    case "web_app_exit_fullscreen":
    case "web_app_set_emoji_status":
    case "web_app_request_emoji_status_access":
      return w("8.0", t);
    default:
      return [
        "iframe_ready",
        "iframe_will_reload",
        "web_app_close",
        "web_app_data_send",
        "web_app_expand",
        "web_app_open_link",
        "web_app_ready",
        "web_app_request_theme",
        "web_app_request_viewport",
        "web_app_setup_main_button",
        "web_app_setup_closing_behavior"
      ].includes(e);
  }
}
function vs(e, t) {
  t || (t = "strict");
  const n = typeof t == "function" ? t : (r) => {
    const { method: o, version: s } = r;
    let a, i;
    if ("param" in r ? (a = `Parameter "${r.param}" of "${o}" method is unsupported in Mini Apps version ${s}`, i = ds) : (a = `Method "${o}" is unsupported in Mini Apps version ${s}`, i = ps), t === "strict")
      throw new p(i, a);
    return console.warn(a);
  };
  return (r, o) => G(r, e) ? Yo(o) && r === "web_app_set_header_color" && "color" in o && !G(r, "color", e) ? n({ version: e, method: r, param: "color" }) : Vt(r, o) : n({ version: e, method: r });
}
function As(e, t, n, r) {
  return Nt("web_app_invoke_custom_method", "custom_method_invoked", {
    ...r || {},
    params: { method: e, params: t, req_id: n },
    capture: wr(n)
  }).then(({ result: o, error: s }) => {
    if (s)
      throw new p(fs, s);
    return o;
  });
}
function Cs() {
  return performance.getEntriesByType("navigation")[0];
}
function x() {
  const e = Cs();
  return !!e && e.type === "reload";
}
let X;
function Rs(e, t) {
  X && X.set(e, t) || t();
}
function vt(e) {
  if (X)
    return e();
  X = /* @__PURE__ */ new Map();
  try {
    e();
  } finally {
    X.forEach((t) => t()), X = void 0;
  }
}
// @__NO_SIDE_EFFECTS__
function c(e, t) {
  t || (t = {});
  const n = t.equals || Object.is;
  let r = [], o = e;
  const s = (u) => {
    if (!n(o, u)) {
      const _ = o;
      o = u, Rs(l, () => {
        [...r].forEach(([g, y]) => {
          g(u, _), y && i(g, !0);
        });
      });
    }
  };
  function a(u) {
    const _ = typeof u != "object" ? { once: u } : u;
    return {
      once: _.once || !1,
      signal: _.signal || !1
    };
  }
  const i = (u, _) => {
    const g = a(_), y = r.findIndex(([L, C]) => L === u && C.once === g.once && C.signal === g.signal);
    y >= 0 && r.splice(y, 1);
  }, l = Object.assign(
    function() {
      return Bs(l), o;
    },
    {
      destroy() {
        r = [];
      },
      set: s,
      reset() {
        s(e);
      },
      sub(u, _) {
        return r.push([u, a(_)]), () => i(u, _);
      },
      unsub: i,
      unsubAll() {
        r = r.filter((u) => u[1].signal);
      }
    }
  );
  return l;
}
const ce = [];
function Bs(e) {
  ce.length && ce[ce.length - 1].add(e);
}
// @__NO_SIDE_EFFECTS__
function d(e, t) {
  let n = /* @__PURE__ */ new Set(), r;
  function o() {
    return r || (r = /* @__PURE__ */ c(a(), t));
  }
  function s() {
    o().set(a());
  }
  function a() {
    n.forEach((u) => {
      u.unsub(s, { signal: !0 });
    });
    const i = /* @__PURE__ */ new Set();
    let l;
    ce.push(i);
    try {
      l = e();
    } finally {
      ce.pop();
    }
    return i.forEach((u) => {
      u.sub(s, { signal: !0 });
    }), n = i, l;
  }
  return Object.assign(function() {
    return o()();
  }, {
    destroy() {
      o().destroy();
    },
    sub(...i) {
      return o().sub(...i);
    },
    unsub(...i) {
      o().unsub(...i);
    },
    unsubAll(...i) {
      o().unsubAll(...i);
    }
  });
}
const Ps = /* @__PURE__ */ c(/* @__PURE__ */ (() => {
  let e = 0;
  return () => (e += 1).toString();
})()), yr = /* @__PURE__ */ c(Vt), V = /* @__PURE__ */ c("0.0");
function Ts(e) {
  e || (e = {});
  const { postEvent: t } = e, n = e.version || J().version;
  V.set(n), yr.set(
    typeof t == "function" ? t : vs(n)
  );
}
function Sr() {
  return Ps()();
}
function oe(e, t, n) {
  return As(e, t, Sr(), {
    ...n || {},
    postEvent: f
  });
}
const E = (e, t, n) => (n || (n = {}), n.postEvent || (n.postEvent = f), Nt(e, t, n)), f = (e, t) => yr()(e, t);
function M(e) {
  return /* @__PURE__ */ d(() => G(e, V()));
}
const ie = "ERR_POPUP_INVALID_PARAMS", $t = "ERR_INVALID_URL", Is = "ERR_INVALID_SLUG", ks = "ERR_DATA_INVALID_SIZE", Os = "ERR_ACCESS_DENIED", Y = "ERR_ALREADY_REQUESTING", Ut = "ERR_ALREADY_OPENED", Ds = "ERR_ALREADY_MOUNTING", xs = "ERR_VARS_ALREADY_BOUND", Ms = "ERR_NOT_AVAILABLE", js = "ERR_NOT_INITIALIZED", kn = "ERR_NOT_SUPPORTED", Ls = "ERR_NOT_MOUNTED", Vs = "ERR_FULLSCREEN_FAILED", Ns = "ERR_EMOJI_STATUS_SET_FAILED";
function On() {
  return typeof window > "u";
}
// @__NO_SIDE_EFFECTS__
function A(e, t, { isSupported: n, isMounted: r, component: o, supports: s } = {}) {
  const a = `${o ? `${o}.` : ""}${e}()`;
  n = n ? Array.isArray(n) || typeof n == "object" && "any" in n ? n : [n] : void 0;
  function i(b) {
    if (s) {
      const m = s[b];
      return G(m[0], m[1], V());
    }
    return !0;
  }
  const l = () => {
    if (!n)
      return;
    const b = `it is unsupported in Mini Apps version ${V()}`;
    function m(R) {
      return typeof R == "string" ? G(R, V()) ? void 0 : b : R.fn() ? void 0 : R.error;
    }
    if (Array.isArray(n)) {
      for (const R of n) {
        const En = m(R);
        if (En)
          return En;
      }
      return;
    }
    let W;
    for (const R of n.any)
      if (W = m(R), !W)
        return;
    return b;
  }, u = (...b) => {
    if (s) {
      for (const m in s)
        if (s[m][2](...b) && !i(m))
          return `option ${m} is not supported in Mini Apps version ${V()}`;
    }
  }, _ = /* @__PURE__ */ d(() => !l()), g = /* @__PURE__ */ d(() => V() !== "0.0"), y = /* @__PURE__ */ d(() => !r || r()), L = /* @__PURE__ */ d(
    () => Tn("simple") && !On() && g() && _() && y()
  );
  let C;
  if (s) {
    C = {};
    for (const b in s)
      C[b] = /* @__PURE__ */ d(() => i(b));
  }
  return Object.assign(
    (...b) => {
      const m = `Unable to call the ${a} ${o ? "method" : "function"}:`;
      if (On() || !Tn("simple"))
        throw new p(
          mr,
          `${m} it can't be called outside Mini Apps`
        );
      if (!g())
        throw new p(
          js,
          `${m} the SDK was not initialized. Use the SDK init() function`
        );
      const W = l();
      if (W)
        throw new p(kn, `${m} ${W}`);
      const R = u(...b);
      if (R)
        throw new p(kn, `${m} ${R}`);
      if (!y())
        throw new p(
          Ls,
          `${m} the component is not mounted. Use the ${o}.mount() method`
        );
      return t(...b);
    },
    t,
    {
      isAvailable: L,
      ifAvailable(...b) {
        return L() ? t(...b) : void 0;
      }
    },
    n ? {
      isSupported: _
    } : {},
    C ? {
      supports: C
    } : {}
  );
}
function Fe(e, t) {
  return t || (t = {}), (n, r, o, s) => /* @__PURE__ */ A(n, r, {
    ...t,
    isSupported: o || t.isSupported,
    supports: s,
    component: e
  });
}
function Q(e, t, n) {
  return Fe(e, { isSupported: n, isMounted: t });
}
function I(e, t) {
  return Fe(e, { isSupported: t });
}
const We = "web_app_setup_back_button", Er = "back_button_pressed", He = "backButton", At = /* @__PURE__ */ c(!1), _e = /* @__PURE__ */ c(!1), qs = M(We), vr = Q(He, _e, We), Ft = I(He, We), $s = vr("hide", () => {
  Wt(!1);
}), Us = Ft("mount", () => {
  _e() || (Wt(x() && T(He) || !1), _e.set(!0));
});
function Wt(e) {
  e !== At() && (f(We, { is_visible: e }), P(He, e), At.set(e));
}
const Fs = Ft(
  "onClick",
  (e) => S(Er, e)
), Ws = Ft(
  "offClick",
  (e) => {
    O(Er, e);
  }
), Hs = vr("show", () => {
  Wt(!0);
});
function zs() {
  _e.set(!1);
}
const Lc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hide: $s,
  isMounted: _e,
  isSupported: qs,
  isVisible: At,
  mount: Us,
  offClick: Ws,
  onClick: Fs,
  show: Hs,
  unmount: zs
}, Symbol.toStringTag, { value: "Module" }));
// @__NO_SIDE_EFFECTS__
function ze(e, t, n, r, o) {
  const s = o === void 0 || o ? h : Promise;
  return Object.assign((...a) => s.resolve().then(async () => {
    if (n()) {
      const l = t();
      throw r.set(l), l;
    }
    vt(() => {
      n.set(
        s.resolve(e(...a))
      ), r.set(void 0);
    });
    let i;
    try {
      i = [!0, await n()];
    } catch (l) {
      i = [!1, l];
    }
    if (vt(() => {
      n.set(void 0), r.set(i[0] ? void 0 : i[1]);
    }), !i[0])
      throw i[1];
    return i[1];
  }), e);
}
// @__NO_SIDE_EFFECTS__
function Ar(e, t, n, r, o, s) {
  const a = /* @__PURE__ */ ze(
    t,
    () => new p(
      Ds,
      `The ${e} component is already mounting`
    ),
    o,
    s
  );
  return (i) => h.resolve().then(async () => {
    if (!r()) {
      const l = await a(i);
      vt(() => {
        r.set(!0), n(l);
      });
    }
  });
}
const $ = Fe, Ge = /* @__PURE__ */ c({ available: !1 }), ke = /* @__PURE__ */ c(!1), Oe = /* @__PURE__ */ c(!1), Je = /* @__PURE__ */ c(!1), Gs = /* @__PURE__ */ d(() => !!Ht()), Cr = /* @__PURE__ */ c(), Ht = /* @__PURE__ */ c(), Js = /* @__PURE__ */ d(() => {
  const e = Ge();
  return e && e.available;
});
function zt(e) {
  return e.available ? {
    available: !0,
    tokenSaved: e.token_saved,
    deviceId: e.device_id,
    accessRequested: e.access_requested,
    type: e.type,
    accessGranted: e.access_granted
  } : {
    available: !1
  };
}
const Dn = "web_app_biometry_get_info", Ys = /* @__PURE__ */ A(
  "requestBiometry",
  (e) => E(Dn, "biometry_info_received", e).then(zt),
  {
    isSupported: Dn
  }
), Ye = "web_app_biometry_request_auth", Qs = "web_app_biometry_request_access", Ks = "web_app_biometry_open_settings", Zs = "web_app_biometry_update_token", Gt = "biometry_info_received", te = "biometry", Xs = M(Ye), ea = $(te), ta = I(te, Ye), Jt = Q(te, Je, Ye);
function Rr() {
  throw new p(Ms, "Biometry is not available");
}
const na = Jt(
  "authenticate",
  (e) => h.withFn(async (t) => {
    if (ke())
      throw new p(Y, "Authentication is already in progress");
    const n = Ge();
    (!n || !n.available) && Rr(), ke.set(!0);
    try {
      const r = await E(
        Ye,
        "biometry_auth_requested",
        {
          abortSignal: t,
          params: {
            reason: ((e || {}).reason || "").trim()
          }
        }
      ), { token: o } = r;
      return typeof o == "string" && Qe({ ...n, token: o }), r;
    } finally {
      ke.set(!1);
    }
  }, e)
), ra = ta("openSettings", () => {
  f(Ks);
}), oa = Jt(
  "requestAccess",
  (e) => h.withFn(async (t) => {
    if (Oe())
      throw new p(Y, "Access request is already in progress");
    Oe.set(!0);
    try {
      const n = await E(Qs, Gt, {
        abortSignal: t,
        params: { reason: (e || {}).reason || "" }
      }).then(zt);
      return n.available || Rr(), Qe(n), n.accessGranted;
    } finally {
      Oe.set(!1);
    }
  }, e)
), sa = ea("mount", /* @__PURE__ */ Ar(
  te,
  (e) => x() && T(te) || Ys(e),
  (e) => {
    S(Gt, Br), Qe(e);
  },
  Je,
  Ht,
  Cr
)), Br = (e) => {
  Qe(zt(e));
};
function Qe(e) {
  Ge.set(e), P(te, e);
}
function aa() {
  O(Gt, Br), Je.set(!1);
}
const ia = Jt(
  "updateToken",
  (e) => (e || (e = {}), E(Zs, "biometry_token_updated", {
    ...e,
    params: {
      token: e.token || "",
      reason: e.reason
    }
  }).then((t) => t.status))
), Vc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  authenticate: na,
  isAuthenticating: ke,
  isAvailable: Js,
  isMounted: Je,
  isMounting: Gs,
  isRequestingAccess: Oe,
  isSupported: Xs,
  mount: sa,
  mountError: Cr,
  mountPromise: Ht,
  openSettings: ra,
  requestAccess: oa,
  state: Ge,
  unmount: aa,
  updateToken: ia
}, Symbol.toStringTag, { value: "Module" }));
function Ke(e, t) {
  return Fe(e, { isMounted: t });
}
const Ze = "closingBehavior", Ct = /* @__PURE__ */ c(!1), me = /* @__PURE__ */ c(!1), Pr = Ke(Ze, me), ca = $(Ze), ua = Pr("disableConfirmation", () => {
  Yt(!1);
}), pa = Pr("enableConfirmation", () => {
  Yt(!0);
}), la = ca("mount", () => {
  me() || (Yt(
    x() && T(Ze) || !1
  ), me.set(!0));
});
function Yt(e) {
  e !== Ct() && (f("web_app_setup_closing_behavior", { need_confirmation: e }), P(Ze, e), Ct.set(e));
}
function da() {
  me.set(!1);
}
const Nc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  disableConfirmation: ua,
  enableConfirmation: pa,
  isConfirmationEnabled: Ct,
  isMounted: me,
  mount: la,
  unmount: da
}, Symbol.toStringTag, { value: "Module" })), Tr = "web_app_invoke_custom_method", Xe = I("cloudStorage", Tr), fa = M(Tr), _a = Xe("deleteItem", (e, t) => {
  const n = Array.isArray(e) ? e : [e];
  return n.length ? oe("deleteStorageValues", { keys: n }, t).then() : h.resolve();
});
function ma(e, t) {
  const n = Array.isArray(e) ? e : [e];
  return n.length ? oe("getStorageValues", { keys: n }, t).then((r) => {
    const o = Ne(
      Object.fromEntries(n.map((s) => [s, N()]))
    )()(r);
    return Array.isArray(e) ? o : o[e];
  }) : h.resolve(typeof e == "string" ? "" : {});
}
const ha = Xe("getItem", ma), ba = Xe("getKeys", (e) => oe("getStorageKeys", {}, e).then(jo(N())())), ga = Xe("setItem", (e, t, n) => oe("saveStorageValue", {
  key: e,
  value: t
}, n).then()), qc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  deleteItem: _a,
  getItem: ha,
  getKeys: ba,
  isSupported: fa,
  setItem: ga
}, Symbol.toStringTag, { value: "Module" })), Be = "web_app_trigger_haptic_feedback", Qt = I("hapticFeedback", Be), wa = M(Be), ya = Qt(
  "impactOccurred",
  (e) => {
    f(Be, {
      type: "impact",
      impact_style: e
    });
  }
), Sa = Qt(
  "notificationOccurred",
  (e) => {
    f(Be, {
      type: "notification",
      notification_type: e
    });
  }
), Ea = Qt(
  "selectionChanged",
  () => {
    f(Be, { type: "selection_change" });
  }
), $c = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  impactOccurred: ya,
  isSupported: wa,
  notificationOccurred: Sa,
  selectionChanged: Ea
}, Symbol.toStringTag, { value: "Module" })), Kt = /* @__PURE__ */ c(void 0);
function j(e) {
  return /* @__PURE__ */ d(() => {
    const t = Kt();
    return t ? t[e] : void 0;
  });
}
const Ir = j("authDate"), kr = j("canSendAfter"), va = /* @__PURE__ */ d(() => {
  const e = Ir(), t = kr();
  return t && e ? new Date(e.getTime() + t * 1e3) : void 0;
}), Aa = j("chat"), Ca = j("chatType"), Ra = j("chatInstance"), Ba = j("hash"), Pa = j("queryId"), Or = /* @__PURE__ */ c(), Ta = j("receiver");
function Ia() {
  const e = J();
  Kt.set(e.initData), Or.set(e.initDataRaw);
}
const ka = j("startParam"), Oa = j("user"), Uc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  authDate: Ir,
  canSendAfter: kr,
  canSendAfterDate: va,
  chat: Aa,
  chatInstance: Ra,
  chatType: Ca,
  hash: Ba,
  queryId: Pa,
  raw: Or,
  receiver: Ta,
  restore: Ia,
  startParam: ka,
  state: Kt,
  user: Oa
}, Symbol.toStringTag, { value: "Module" }));
function Fc(e) {
  return Oo()(e);
}
const Zt = "web_app_open_invoice", Da = I("invoice", Zt), De = /* @__PURE__ */ c(!1), xa = M(Zt);
async function Dr(e, t, n) {
  if (De())
    throw new p(Ut, "An invoice is already opened");
  let r;
  if (t === "url") {
    const { hostname: o, pathname: s } = new URL(e, window.location.href);
    if (o !== "t.me")
      throw new p($t, `Link has unexpected hostname: ${o}`);
    const a = s.match(/^\/(\$|invoice\/)([A-Za-z0-9\-_=]+)$/);
    if (!a)
      throw new p(
        Is,
        'Expected to receive a link with a pathname in format "/invoice/{slug}" or "/${slug}"'
      );
    [, , r] = a;
  } else
    r = e, n = t;
  return De.set(!0), E(Zt, "invoice_closed", {
    ...n,
    params: { slug: r },
    capture: (o) => r === o.slug
  }).then((o) => o.status).finally(() => {
    De.set(!1);
  });
}
const Ma = Da("open", Dr), Wc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  _open: Dr,
  isOpened: De,
  isSupported: xa,
  open: Ma
}, Symbol.toStringTag, { value: "Module" }));
function xr(e) {
  return Object.fromEntries(
    Object.entries(e).filter((t) => t[1] !== void 0)
  );
}
function Mr(e) {
  const t = Qn(e);
  return Math.sqrt(
    [0.299, 0.587, 0.114].reduce((n, r, o) => {
      const s = parseInt(t.slice(1 + o * 2, 1 + (o + 1) * 2), 16);
      return n + s * s * r;
    }, 0)
  ) < 120;
}
const he = /* @__PURE__ */ c(!1), xe = /* @__PURE__ */ c(!1), U = /* @__PURE__ */ c({});
function v(e) {
  return /* @__PURE__ */ d(() => U()[e]);
}
const ja = v("accentTextColor"), Xt = v("bgColor"), en = v("buttonColor"), jr = v("buttonTextColor"), Lr = v("bottomBarBgColor"), La = v("destructiveTextColor"), Va = v("headerBgColor"), Na = v("hintColor"), qa = /* @__PURE__ */ d(() => {
  const { bgColor: e } = U();
  return !e || Mr(e);
}), $a = v("linkColor"), Ue = v("secondaryBgColor"), Ua = v("sectionBgColor"), Fa = v("sectionHeaderTextColor"), Wa = v("sectionSeparatorColor"), Ha = v("subtitleTextColor"), za = v("textColor");
function K(e) {
  return /* @__PURE__ */ d(() => tn()[e]);
}
const ue = /* @__PURE__ */ c({
  hasShineEffect: !1,
  isEnabled: !0,
  isLoaderVisible: !1,
  isVisible: !1,
  text: "Continue"
}), tn = /* @__PURE__ */ d(() => {
  const e = ue();
  return {
    ...e,
    backgroundColor: e.backgroundColor || en() || "#2481cc",
    textColor: e.textColor || jr() || "#ffffff"
  };
}), be = /* @__PURE__ */ c(!1), Ga = K("backgroundColor"), Ja = K("hasShineEffect"), Ya = K("isEnabled"), Qa = K("isLoaderVisible"), Ka = K("isVisible"), Za = K("text"), Xa = K("textColor"), ei = "web_app_setup_main_button", Vr = "main_button_pressed", et = "mainButton", nn = $(et), ti = Ke(et, be), ni = nn("mount", () => {
  if (!be()) {
    const e = x() && T(et);
    e && ue.set(e), be.set(!0);
  }
}), ri = nn(
  "onClick",
  (e) => S(Vr, e)
), oi = nn(
  "offClick",
  (e) => {
    O(Vr, e);
  }
), si = ti(
  "setParams",
  (e) => {
    ue.set({ ...ue(), ...xr(e) }), P(et, ue());
    const t = tn();
    t.text && f(ei, {
      color: t.backgroundColor,
      has_shine_effect: t.hasShineEffect,
      is_active: t.isEnabled,
      is_progress_visible: t.isLoaderVisible,
      is_visible: t.isVisible,
      text: t.text,
      text_color: t.textColor
    });
  }
);
function ai() {
  be.set(!1);
}
const Hc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  backgroundColor: Ga,
  hasShineEffect: Ja,
  isEnabled: Ya,
  isLoaderVisible: Qa,
  isMounted: be,
  isVisible: Ka,
  mount: ni,
  offClick: oi,
  onClick: ri,
  setParams: si,
  state: tn,
  text: Za,
  textColor: Xa,
  unmount: ai
}, Symbol.toStringTag, { value: "Module" }));
function rn() {
  throw new p(
    xs,
    "CSS variables are already bound"
  );
}
function ii(e) {
  return Mo()(e);
}
const tt = "themeParams", Nr = "theme_changed", ci = $(tt), ui = Ke(tt, he), pi = ui(
  "bindCssVars",
  (e) => {
    xe() && rn(), e || (e = (r) => `--tg-theme-${xt(r)}`);
    function t(r) {
      Object.entries(U()).forEach(([o, s]) => {
        s && r(o, s);
      });
    }
    function n() {
      t((r, o) => {
        Mt(e(r), o);
      });
    }
    return n(), U.sub(n), xe.set(!0), () => {
      t(jt), U.unsub(n), xe.set(!1);
    };
  }
), qr = ci("mount", () => {
  he() || (S(Nr, $r), U.set(
    x() && T(tt) || J().themeParams
  ), he.set(!0));
}), $r = (e) => {
  const t = ii(e.theme_params);
  U.set(t), P(tt, t);
};
function li() {
  O(Nr, $r), he.set(!1);
}
// @__NO_SIDE_EFFECTS__
function Ur(e) {
  return /* @__PURE__ */ d(() => {
    const t = e();
    return de(t) ? t : t === "bg_color" ? Xt() : Ue();
  });
}
const ge = /* @__PURE__ */ c("bg_color"), on = /* @__PURE__ */ Ur(ge), we = /* @__PURE__ */ c("bottom_bar_bg_color"), sn = /* @__PURE__ */ d(() => {
  const e = we();
  return de(e) ? e : e === "bottom_bar_bg_color" ? Lr() || Ue() : e === "secondary_bg_color" ? Ue() : Xt();
}), ye = /* @__PURE__ */ c("bg_color"), Fr = /* @__PURE__ */ Ur(ye), Se = /* @__PURE__ */ c(!1), Me = /* @__PURE__ */ c(!1), di = /* @__PURE__ */ d(() => {
  const e = on();
  return e ? Mr(e) : !1;
}), Wr = /* @__PURE__ */ d(() => ({
  backgroundColor: ge(),
  bottomBarColor: we(),
  headerColor: ye()
})), Rt = "web_app_set_background_color", Bt = "web_app_set_bottom_bar_color", je = "web_app_set_header_color", Pe = "miniApp", an = {
  any: [
    Rt,
    Bt,
    je
  ]
}, fi = /* @__PURE__ */ d(() => an.any.some((e) => G(e, V()))), Hr = $(Pe), _i = I(Pe, an), nt = Q(Pe, Se, an), mi = nt(
  "bindCssVars",
  (e) => {
    Me() && rn();
    const [t, n] = ne();
    function r(o, s) {
      function a() {
        Mt(o, s() || null);
      }
      a(), t(s.sub(a), jt.bind(null, o));
    }
    return e || (e = (o) => `--tg-${xt(o)}`), r(e("bgColor"), on), r(e("bottomBarColor"), sn), r(e("headerColor"), Fr), t(() => {
      Me.set(!1);
    }), Me.set(!0), n;
  }
), hi = Hr("close", (e) => {
  f("web_app_close", { return_back: e });
}), bi = _i(
  "mount",
  () => {
    if (!Se()) {
      const e = x() && T(Pe);
      qr(), zr.ifAvailable(e ? e.backgroundColor : "bg_color"), Gr.ifAvailable(e ? e.bottomBarColor : "bottom_bar_bg_color"), Jr.ifAvailable(e ? e.headerColor : "bg_color"), Se.set(!0);
    }
  }
), gi = Hr("ready", () => {
  f("web_app_ready");
});
function cn() {
  P(Pe, Wr());
}
const zr = nt(
  "setBackgroundColor",
  (e) => {
    e !== ge() && (f(Rt, { color: e }), ge.set(e), cn());
  },
  Rt
), Gr = nt(
  "setBottomBarColor",
  (e) => {
    e !== we() && (f(Bt, { color: e }), we.set(e), cn());
  },
  Bt
), Jr = nt(
  "setHeaderColor",
  (e) => {
    e !== ye() && (f(je, de(e) ? { color: e } : { color_key: e }), ye.set(e), cn());
  },
  je,
  {
    rgb: [je, "color", de]
  }
);
function wi() {
  Se.set(!1);
}
const zc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  backgroundColor: ge,
  backgroundColorRGB: on,
  bindCssVars: mi,
  bottomBarColor: we,
  bottomBarColorRGB: sn,
  close: hi,
  headerColor: ye,
  headerColorRGB: Fr,
  isCssVarsBound: Me,
  isDark: di,
  isMounted: Se,
  isSupported: fi,
  mount: bi,
  ready: gi,
  setBackgroundColor: zr,
  setBottomBarColor: Gr,
  setHeaderColor: Jr,
  state: Wr,
  unmount: wi
}, Symbol.toStringTag, { value: "Module" }));
function yi(e) {
  const t = e.message.trim(), n = (e.title || "").trim(), r = e.buttons || [];
  if (n.length > 64)
    throw new p(ie, `Invalid title: ${n}`);
  if (!t || t.length > 256)
    throw new p(ie, `Invalid message: ${t}`);
  if (r.length > 3)
    throw new p(ie, `Invalid buttons count: ${r.length}`);
  return {
    title: n,
    message: t,
    buttons: r.length ? r.map((o, s) => {
      const a = o.id || "";
      if (a.length > 64)
        throw new p(ie, `Button with index ${s} has invalid id: ${a}`);
      if (!o.type || o.type === "default" || o.type === "destructive") {
        const i = o.text.trim();
        if (!i || i.length > 64)
          throw new p(ie, `Button with index ${s} has invalid text: ${i}`);
        return { type: o.type, text: i, id: a };
      }
      return { type: o.type, id: a };
    }) : [{ type: "close", id: "" }]
  };
}
const un = "web_app_open_popup", Si = I("popup", un), Le = /* @__PURE__ */ c(!1), Ei = M(un), vi = Si(
  "open",
  async (e) => {
    if (Le())
      throw new p(Ut, "A popup is already opened");
    Le.set(!0);
    try {
      const { button_id: t = null } = await E(un, "popup_closed", {
        ...e,
        params: yi(e)
      });
      return t;
    } finally {
      Le.set(!1);
    }
  }
), Gc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  isOpened: Le,
  isSupported: Ei,
  open: vi
}, Symbol.toStringTag, { value: "Module" })), Ai = "web_app_close_scan_qr_popup", pn = "web_app_open_scan_qr_popup", Ci = "scan_qr_popup_closed", Ri = "qr_text_received", Yr = I("qrScanner", pn), Pt = Yr("close", () => {
  ee.set(!1), f(Ai);
}), ee = /* @__PURE__ */ c(!1), Bi = M(pn);
function Pi(e) {
  return h.withFn((t) => {
    if (ee())
      throw new p(Ut, "The QR Scanner is already opened");
    ee.set(!0), e || (e = {});
    const { onCaptured: n, text: r, capture: o } = e, [, s] = ne(
      // Whenever the scanner was closed for some reason (by a developer or a
      // user), we should resolve the promise with undefined.
      ee.sub(() => {
        a.resolve();
      }),
      // Whenever user closed the scanner, update the isOpened signal state.
      S(Ci, () => {
        ee.set(!1);
      }),
      // Whenever some QR was scanned, we should check if it must be captured.
      S(Ri, (i) => {
        n ? n(i.data) : (!o || o(i.data)) && (a.resolve(i.data), Pt());
      })
    ), a = new ts({ abortSignal: t }).catch(Pt).finally(s);
    return (e.postEvent || f)(pn, { text: r }), a;
  }, e);
}
const Ti = Yr("open", Pi), Jc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  close: Pt,
  isOpened: ee,
  isSupported: Bi,
  open: Ti
}, Symbol.toStringTag, { value: "Module" }));
function F(e) {
  return /* @__PURE__ */ d(() => ln()[e]);
}
const pe = /* @__PURE__ */ c({
  hasShineEffect: !1,
  isEnabled: !0,
  isLoaderVisible: !1,
  isVisible: !1,
  position: "left",
  text: "Cancel"
}), ln = /* @__PURE__ */ d(() => {
  const e = pe();
  return {
    ...e,
    backgroundColor: e.backgroundColor || sn() || "#000000",
    textColor: e.textColor || en() || "#2481cc"
  };
}), Ee = /* @__PURE__ */ c(!1), Ii = F("backgroundColor"), ki = F("hasShineEffect"), Oi = F("isEnabled"), Di = F("isLoaderVisible"), xi = F("isVisible"), Mi = F("position"), ji = F("text"), Li = F("textColor"), rt = "web_app_setup_secondary_button", Qr = "secondary_button_pressed", ot = "secondaryButton", dn = I(ot, rt), Vi = Q(ot, Ee, rt), Ni = M(rt), qi = dn("mount", () => {
  if (!Ee()) {
    const e = x() && T(ot);
    e && pe.set(e), Ee.set(!0);
  }
}), $i = dn(
  "onClick",
  (e) => S(Qr, e)
), Ui = dn(
  "offClick",
  (e) => {
    O(Qr, e);
  }
), Fi = Vi(
  "setParams",
  (e) => {
    pe.set({
      ...pe(),
      ...Object.fromEntries(
        Object.entries(e).filter(([, n]) => n !== void 0)
      )
    }), P(ot, pe());
    const t = ln();
    t.text && f(rt, {
      color: t.backgroundColor,
      has_shine_effect: t.hasShineEffect,
      is_active: t.isEnabled,
      is_progress_visible: t.isLoaderVisible,
      is_visible: t.isVisible,
      position: t.position,
      text: t.text,
      text_color: t.textColor
    });
  }
);
function Wi() {
  Ee.set(!1);
}
const Yc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  backgroundColor: Ii,
  hasShineEffect: ki,
  isEnabled: Oi,
  isLoaderVisible: Di,
  isMounted: Ee,
  isSupported: Ni,
  isVisible: xi,
  mount: qi,
  offClick: Ui,
  onClick: $i,
  position: Mi,
  setParams: Fi,
  state: ln,
  text: ji,
  textColor: Li,
  unmount: Wi
}, Symbol.toStringTag, { value: "Module" })), st = "web_app_setup_settings_button", Kr = "settings_button_pressed", at = "settingsButton", Tt = /* @__PURE__ */ c(!1), ve = /* @__PURE__ */ c(!1), Hi = M(st), fn = I(at, st), Zr = Q(at, ve, st), zi = Zr("hide", () => {
  _n(!1);
}), Gi = fn("mount", () => {
  ve() || (_n(x() && T(at) || !1), ve.set(!0));
});
function _n(e) {
  e !== Tt() && (f(st, { is_visible: e }), P(at, e), Tt.set(e));
}
const Ji = fn(
  "onClick",
  (e) => S(Kr, e)
), Yi = fn(
  "offClick",
  (e) => {
    O(Kr, e);
  }
), Qi = Zr("show", () => {
  _n(!0);
});
function Ki() {
  ve.set(!1);
}
const Qc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hide: zi,
  isMounted: ve,
  isSupported: Hi,
  isVisible: Tt,
  mount: Gi,
  offClick: Yi,
  onClick: Ji,
  show: Qi,
  unmount: Ki
}, Symbol.toStringTag, { value: "Module" })), it = "web_app_setup_swipe_behavior", ct = "swipeBehavior", Ae = /* @__PURE__ */ c(!1), Zi = M(it), It = /* @__PURE__ */ c(!0), Xi = I(ct, it), Xr = Q(ct, Ae, it), ec = Xr("disableVertical", () => {
  mn(!1);
}), tc = Xr("enableVertical", () => {
  mn(!0);
}), nc = Xi("mount", () => {
  Ae() || (mn(
    x() && T(ct) || !1,
    !0
  ), Ae.set(!0));
});
function mn(e, t) {
  (e !== It() || t) && (f(it, { allow_vertical_swipe: e }), P(ct, e), It.set(e));
}
function rc() {
  Ae.set(!1);
}
const Kc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  disableVertical: ec,
  enableVertical: tc,
  isMounted: Ae,
  isSupported: Zi,
  isVerticalEnabled: It,
  mount: nc,
  unmount: rc
}, Symbol.toStringTag, { value: "Module" })), Zc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  accentTextColor: ja,
  backgroundColor: Xt,
  bindCssVars: pi,
  bottomBarBgColor: Lr,
  buttonColor: en,
  buttonTextColor: jr,
  destructiveTextColor: La,
  headerBackgroundColor: Va,
  hintColor: Na,
  isCssVarsBound: xe,
  isDark: qa,
  isMounted: he,
  linkColor: $a,
  mount: qr,
  secondaryBackgroundColor: Ue,
  sectionBackgroundColor: Ua,
  sectionHeaderTextColor: Fa,
  sectionSeparatorColor: Wa,
  state: U,
  subtitleTextColor: Ha,
  textColor: za,
  unmount: li
}, Symbol.toStringTag, { value: "Module" })), se = "viewport", eo = "web_app_request_fullscreen", oc = "fullscreen_failed", hn = "fullscreen_changed", to = "safe_area_changed", no = "content_safe_area_changed", ro = "viewport_changed", xn = "web_app_request_safe_area", Mn = "web_app_request_content_safe_area", jn = {
  left: 0,
  top: 0,
  bottom: 0,
  right: 0
};
function ht(e) {
  return Math.max(e, 0);
}
const le = /* @__PURE__ */ c({
  contentSafeAreaInsets: jn,
  height: 0,
  isExpanded: !1,
  isFullscreen: !1,
  safeAreaInsets: jn,
  stableHeight: 0,
  width: 0
});
function Z(e) {
  return /* @__PURE__ */ d(() => le()[e]);
}
function ae(e) {
  const { height: t, stableHeight: n, width: r } = e;
  le.set({
    ...le(),
    ...xr({
      ...e,
      height: t ? ht(t) : void 0,
      width: r ? ht(r) : void 0,
      stableHeight: n ? ht(n) : void 0
    })
  }), P(se, le());
}
function sc() {
  return T(se);
}
const oo = Z("isFullscreen"), bn = /* @__PURE__ */ c(), ac = /* @__PURE__ */ d(() => !!bn()), so = /* @__PURE__ */ c(), Te = /* @__PURE__ */ c(!1), ic = /* @__PURE__ */ d(() => !!ut()), ao = /* @__PURE__ */ c(void 0), ut = /* @__PURE__ */ c(), cc = Q(se, Te, eo);
function io(e, t) {
  return cc(e, /* @__PURE__ */ ze(
    (n) => E(t, [hn, oc], n).then((r) => {
      if ("error" in r) {
        if (r.error === "ALREADY_FULLSCREEN")
          return !0;
        throw new p(Vs, "Fullscreen request failed", r.error);
      }
      return r.is_fullscreen;
    }).then((r) => {
      r !== oo() && ae({ isFullscreen: r });
    }),
    () => new p(Y, "Fullscreen mode change is already being requested"),
    bn,
    so
  ));
}
const uc = io("requestFullscreen", eo), pc = io("exitFullscreen", "web_app_exit_fullscreen"), co = $(se), lc = Ke(se, Te);
function pt(e) {
  return /* @__PURE__ */ d(() => gn()[e]);
}
const gn = Z("safeAreaInsets"), uo = pt("bottom"), po = pt("left"), lo = pt("right"), fo = pt("top");
function lt(e) {
  return /* @__PURE__ */ d(() => wn()[e]);
}
const wn = Z("contentSafeAreaInsets"), _o = lt("bottom"), mo = lt("left"), ho = lt("right"), bo = lt("top"), dc = /* @__PURE__ */ A(
  "requestContentSafeAreaInsets",
  (e) => E(Mn, "content_safe_area_changed", e),
  { isSupported: Mn }
), fc = /* @__PURE__ */ A(
  "requestSafeAreaInsets",
  (e) => E(xn, "safe_area_changed", e),
  { isSupported: xn }
);
function _c(e) {
  return E("web_app_request_viewport", "viewport_changed", e).then((t) => ({
    height: t.height,
    width: t.width,
    isExpanded: t.is_expanded,
    isStable: t.is_state_stable
  }));
}
const go = (e) => {
  const { height: t } = e;
  ae({
    isExpanded: e.is_expanded,
    height: t,
    width: e.width,
    stableHeight: e.is_state_stable ? t : void 0
  });
}, wo = (e) => {
  ae({ isFullscreen: e.is_fullscreen });
}, yo = (e) => {
  ae({ safeAreaInsets: e });
}, So = (e) => {
  ae({ contentSafeAreaInsets: e });
}, mc = co("mount", /* @__PURE__ */ Ar(
  se,
  (e) => h.resolve().then(async () => {
    const t = x() && sc();
    if (t)
      return t;
    const [
      n,
      r
    ] = await h.all([
      fc.ifAvailable(e) || gn(),
      dc.ifAvailable(e) || wn()
    ]), o = J(), s = {
      contentSafeAreaInsets: r,
      isFullscreen: !!o.fullscreen,
      safeAreaInsets: n
    };
    if (["macos", "tdesktop", "unigram", "webk", "weba", "web"].includes(o.platform)) {
      const a = window;
      return {
        ...s,
        height: a.innerHeight,
        isExpanded: !0,
        stableHeight: a.innerHeight,
        width: a.innerWidth
      };
    }
    return _c(e).then((a) => ({
      ...s,
      height: a.height,
      isExpanded: a.isExpanded,
      stableHeight: a.isStable ? a.height : 0,
      width: a.width
    }));
  }),
  (e) => {
    S(ro, go), S(hn, wo), S(to, yo), S(no, So), ae(e);
  },
  Te,
  ut,
  ao
));
function hc() {
  const e = ut();
  e && e.cancel(), O(ro, go), O(hn, wo), O(to, yo), O(no, So), Te.set(!1);
}
const Ve = /* @__PURE__ */ c(!1), yn = Z("height"), Sn = Z("stableHeight"), Eo = Z("width"), bc = lc(
  "bindCssVars",
  (e) => {
    Ve() && rn(), e || (e = (n) => `--tg-viewport-${xt(n)}`);
    const t = [
      ["height", yn],
      ["stableHeight", Sn],
      ["width", Eo],
      ["safeAreaInsetTop", fo],
      ["safeAreaInsetBottom", uo],
      ["safeAreaInsetLeft", po],
      ["safeAreaInsetRight", lo],
      ["contentSafeAreaInsetTop", bo],
      ["contentSafeAreaInsetBottom", _o],
      ["contentSafeAreaInsetLeft", mo],
      ["contentSafeAreaInsetRight", ho]
    ].reduce((n, [r, o]) => {
      const s = e(r);
      if (s) {
        const a = () => {
          Mt(s, `${o()}px`);
        };
        n.push([a, o.sub(a), s]);
      }
      return n;
    }, []);
    return t.forEach((n) => {
      n[0]();
    }), Ve.set(!0), () => {
      t.forEach((n) => {
        n[1](), jt(n[2]);
      }), Ve.set(!1);
    };
  }
), gc = co("expand", () => {
  f("web_app_expand");
}), wc = Z("isExpanded"), yc = /* @__PURE__ */ d(() => yn() === Sn()), Xc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bindCssVars: bc,
  changeFullscreenError: so,
  changeFullscreenPromise: bn,
  contentSafeAreaInsetBottom: _o,
  contentSafeAreaInsetLeft: mo,
  contentSafeAreaInsetRight: ho,
  contentSafeAreaInsetTop: bo,
  contentSafeAreaInsets: wn,
  exitFullscreen: pc,
  expand: gc,
  height: yn,
  isChangingFullscreen: ac,
  isCssVarsBound: Ve,
  isExpanded: wc,
  isFullscreen: oo,
  isMounted: Te,
  isMounting: ic,
  isStable: yc,
  mount: mc,
  mountError: ao,
  mountPromise: ut,
  requestFullscreen: uc,
  safeAreaInsetBottom: uo,
  safeAreaInsetLeft: po,
  safeAreaInsetRight: lo,
  safeAreaInsetTop: fo,
  safeAreaInsets: gn,
  stableHeight: Sn,
  state: le,
  unmount: hc,
  width: Eo
}, Symbol.toStringTag, { value: "Module" })), Ln = "web_app_request_emoji_status_access", vo = /* @__PURE__ */ c(), Sc = /* @__PURE__ */ c(), eu = /* @__PURE__ */ d(() => !!vo()), tu = /* @__PURE__ */ A(
  "requestEmojiStatusAccess",
  /* @__PURE__ */ ze(
    () => E(Ln, "emoji_status_access_requested").then((e) => e.status),
    () => new p(
      Y,
      "Emoji status access request is currently in progress"
    ),
    vo,
    Sc,
    !1
  ),
  { isSupported: Ln }
), Vn = "web_app_set_emoji_status", Ao = /* @__PURE__ */ c(), Ec = /* @__PURE__ */ c(), nu = /* @__PURE__ */ d(() => !!Ao()), ru = /* @__PURE__ */ A(
  "setEmojiStatus",
  /* @__PURE__ */ ze(
    async (e, t) => {
      const n = await E(Vn, ["emoji_status_set", "emoji_status_failed"], {
        params: {
          custom_emoji_id: e,
          duration: t
        }
      });
      if (n && "error" in n)
        throw new p(Ns, "Failed to set emoji status", n.error);
    },
    () => new p(
      Y,
      "Emoji status set request is currently in progress"
    ),
    Ao,
    Ec,
    !1
  ),
  { isSupported: Vn }
), vc = $(), ou = vc(
  "openLink",
  (e, t) => {
    if (typeof e == "string")
      try {
        e = new URL(e);
      } catch (n) {
        throw new p($t, `"${e.toString()}" is invalid URL`, n);
      }
    t || (t = {}), f("web_app_open_link", {
      url: e.toString(),
      try_browser: t.tryBrowser,
      try_instant_view: t.tryInstantView
    });
  }
), Nn = "web_app_open_tg_link", Ac = $(), Cc = Ac(
  "openTelegramLink",
  (e) => {
    const t = e.toString();
    if (!t.match(/^https:\/\/t.me\/.+/))
      throw new p($t, `"${t}" is invalid URL`);
    if (!G(Nn, V())) {
      window.location.href = t;
      return;
    }
    e = new URL(e), f(Nn, { path_full: e.pathname + e.search });
  }
), Rc = $(), su = Rc(
  "shareURL",
  (e, t) => {
    Cc(
      "https://t.me/share/url?" + new URLSearchParams({ url: e, text: t || "" }).toString().replace(/\+/g, "%20")
    );
  }
), kt = "web_app_request_phone", bt = /* @__PURE__ */ c(!1), Bc = /* @__PURE__ */ A(
  "requestPhoneAccess",
  (e) => {
    if (bt())
      throw new p(Y, "Phone access request is currently in progress");
    return bt.set(!0), E(kt, "phone_requested", e).then((t) => t.status).finally(() => {
      bt.set(!1);
    });
  },
  {
    isSupported: kt
  }
);
function qn(e) {
  return e || (e = {}), oe("getRequestedContact", {}, {
    ...e,
    timeout: e.timeout || 5e3
  }).then(
    Yn({
      contact: Ne({
        userId: ["user_id", qe()],
        phoneNumber: ["phone_number", N()],
        firstName: ["first_name", N()],
        lastName: ["last_name", N(!0)]
      })(),
      authDate: ["auth_date", Ot()],
      hash: N()
    })()
  );
}
const au = /* @__PURE__ */ A(
  "requestContact",
  (e) => h.withFn(
    async (t) => {
      const n = { abortSignal: t };
      try {
        return await qn(n);
      } catch {
      }
      if (await Bc(n) !== "sent")
        throw new p(Os, "User denied access");
      let r = 50;
      for (; !t.aborted; ) {
        try {
          return await qn(n);
        } catch {
        }
        await ns(r), r += 50;
      }
      return null;
    },
    e
  ),
  {
    isSupported: kt
  }
), $n = "web_app_request_write_access", gt = /* @__PURE__ */ c(!1), iu = /* @__PURE__ */ A(
  "requestWriteAccess",
  (e) => {
    if (gt())
      throw new p(Y, "Write access request is currently in progress");
    return gt.set(!0), E($n, "write_access_requested", e).then((t) => t.status).finally(() => {
      gt.set(!1);
    });
  },
  {
    isSupported: $n
  }
), cu = /* @__PURE__ */ A(
  "getCurrentTime",
  (e) => oe("getCurrentTime", {}, e).then(Ot()),
  {
    isSupported: "web_app_invoke_custom_method"
  }
), Un = "web_app_read_text_from_clipboard", uu = /* @__PURE__ */ A(
  "readTextFromClipboard",
  (e) => {
    const t = Sr();
    return E(Un, "clipboard_text_received", {
      ...e,
      params: { req_id: t },
      capture: wr(t)
    }).then(({ data: n = null }) => n);
  },
  {
    isSupported: Un
  }
), pu = /* @__PURE__ */ A(
  "sendData",
  (e) => {
    const { size: t } = new Blob([e]);
    if (!t || t > 4096)
      throw new p(ks, t ? "Maximum size of data to send is 4096 bytes" : "Attempted to send empty data");
    f("web_app_data_send", { data: e });
  }
), Fn = "web_app_share_to_story", lu = /* @__PURE__ */ A(
  "shareStory",
  (e, t) => {
    t || (t = {}), f(Fn, {
      text: t.text,
      media_url: e,
      widget_link: t.widgetLink
    });
  },
  { isSupported: Fn }
), Wn = "web_app_switch_inline_query", du = /* @__PURE__ */ A(
  "switchInlineQuery",
  (e, t) => {
    f(Wn, {
      query: e,
      chat_types: t || []
    });
  },
  {
    isSupported: [Wn, {
      fn: () => !!J().botInline,
      error: "Mini App should be ran in Bot inline mode"
    }]
  }
);
function fu(e) {
  try {
    return { result: e() };
  } catch (t) {
    return { error: t };
  }
}
function _u(e) {
  Ts(e), ys();
  const [t, n] = ne(
    S("reload_iframe", () => {
      f("iframe_will_reload"), window.location.reload();
    }),
    Ss
  ), { acceptCustomStyles: r = !0 } = e || {};
  if (r) {
    const o = document.createElement("style");
    o.id = "telegram-custom-styles", document.head.appendChild(o), t(
      S("set_custom_style", (s) => {
        o.innerHTML = s;
      }),
      () => {
        document.head.removeChild(o);
      }
    );
  }
  return f("iframe_ready", { reload_supported: !0 }), n;
}
function mu() {
  return Co(J, []);
}
function hu(e) {
  return Ro((t) => e.sub(t), e);
}
export {
  Ps as $createRequestId,
  as as $debug,
  yr as $postEvent,
  _s as $targetOrigin,
  V as $version,
  h as CancelablePromise,
  ur as ERR_ABORTED,
  Os as ERR_ACCESS_DENIED,
  Ds as ERR_ALREADY_MOUNTING,
  Ut as ERR_ALREADY_OPENED,
  Y as ERR_ALREADY_REQUESTING,
  pr as ERR_CANCELED,
  xs as ERR_CSS_VARS_ALREADY_BOUND,
  fs as ERR_CUSTOM_METHOD_ERR_RESPONSE,
  ks as ERR_DATA_INVALID_SIZE,
  Ns as ERR_EMOJI_STATUS_SET_FAILED,
  Vs as ERR_FULLSCREEN_FAILED,
  Is as ERR_INVALID_SLUG,
  $t as ERR_INVALID_URL,
  Po as ERR_INVALID_VALUE,
  ds as ERR_METHOD_PARAMETER_UNSUPPORTED,
  ps as ERR_METHOD_UNSUPPORTED,
  Ms as ERR_NOT_AVAILABLE,
  js as ERR_NOT_INITIALIZED,
  Ls as ERR_NOT_MOUNTED,
  kn as ERR_NOT_SUPPORTED,
  zn as ERR_PARSE,
  ie as ERR_POPUP_INVALID_PARAMS,
  ls as ERR_RETRIEVE_LP_FAILED,
  lr as ERR_TIMED_OUT,
  Io as ERR_UNEXPECTED_TYPE,
  To as ERR_UNEXPECTED_VALUE,
  mr as ERR_UNKNOWN_ENV,
  p as TypedError,
  cr as addEventListener,
  na as authenticateBiometry,
  Lc as backButton,
  mi as bindMiniAppCssVars,
  pi as bindThemeParamsCssVars,
  bc as bindViewportCssVars,
  Vc as biometry,
  Cr as biometryMountError,
  Ge as biometryState,
  so as changeFullscreenError,
  bn as changeFullscreenPromise,
  wt as classNames,
  hi as closeMiniApp,
  Pt as closeQrScanner,
  Nc as closingBehavior,
  qc as cloudStorage,
  Es as compareVersions,
  vs as createPostEvent,
  ys as defineEventHandlers,
  _a as deleteCloudStorageItem,
  jt as deleteCssVar,
  ua as disableClosingConfirmation,
  ec as disableVerticalSwipes,
  Et as emitMiniAppsEvent,
  pa as enableClosingConfirmation,
  tc as enableVerticalSwipes,
  pc as exitFullscreen,
  gc as expandViewport,
  ha as getCloudStorageItem,
  ba as getCloudStorageKeys,
  cu as getCurrentTime,
  $c as hapticFeedback,
  ya as hapticFeedbackImpactOccurred,
  Sa as hapticFeedbackNotificationOccurred,
  Ea as hapticFeedbackSelectionChanged,
  $s as hideBackButton,
  zi as hideSettingsButton,
  _u as init,
  Uc as initData,
  Ir as initDataAuthDate,
  kr as initDataCanSendAfter,
  va as initDataCanSendAfterDate,
  Aa as initDataChat,
  Ra as initDataChatInstance,
  Ca as initDataChatType,
  Ba as initDataHash,
  Pa as initDataQueryId,
  Or as initDataRaw,
  Ta as initDataReceiver,
  ka as initDataStartParam,
  Kt as initDataState,
  Oa as initDataUser,
  Wc as invoice,
  As as invokeCustomMethod,
  Oc as isAbortError,
  ke as isAuthenticatingBiometry,
  _e as isBackButtonMounted,
  qs as isBackButtonSupported,
  At as isBackButtonVisible,
  Je as isBiometryMounted,
  Gs as isBiometryMounting,
  Xs as isBiometrySupported,
  Dc as isCanceledError,
  ac as isChangingFullscreen,
  me as isClosingBehaviorMounted,
  Ct as isClosingConfirmationEnabled,
  fa as isCloudStorageSupported,
  Mr as isColorDark,
  oo as isFullscreen,
  wa as isHapticFeedbackSupported,
  Ko as isIframe,
  De as isInvoiceOpened,
  xa as isInvoiceSupported,
  Ya as isMainButtonEnabled,
  Qa as isMainButtonLoaderVisible,
  be as isMainButtonMounted,
  Ka as isMainButtonVisible,
  Me as isMiniAppCssVarsBound,
  di as isMiniAppDark,
  Se as isMiniAppMounted,
  fi as isMiniAppSupported,
  Le as isPopupOpened,
  Ei as isPopupSupported,
  ee as isQrScannerOpened,
  Bi as isQrScannerSupported,
  de as isRGB,
  Do as isRGBShort,
  Kn as isRecord,
  Oe as isRequestingBiometryAccess,
  eu as isRequestingEmojiStatusAccess,
  bt as isRequestingPhoneAccess,
  gt as isRequestingWriteAccess,
  On as isSSR,
  Oi as isSecondaryButtonEnabled,
  Di as isSecondaryButtonLoaderVisible,
  Ee as isSecondaryButtonMounted,
  Ni as isSecondaryButtonSupported,
  xi as isSecondaryButtonVisible,
  nu as isSettingEmojiStatus,
  ve as isSettingsButtonMounted,
  Hi as isSettingsButtonSupported,
  Tt as isSettingsButtonVisible,
  Ae as isSwipeBehaviorMounted,
  Zi as isSwipeBehaviorSupported,
  Tn as isTMA,
  xe as isThemeParamsCssVarsBound,
  qa as isThemeParamsDark,
  he as isThemeParamsMounted,
  kc as isTimeoutError,
  It as isVerticalSwipesEnabled,
  Ve as isViewportCssVarsBound,
  wc as isViewportExpanded,
  Te as isViewportMounted,
  ic as isViewportMounting,
  yc as isViewportStable,
  Hc as mainButton,
  Ga as mainButtonBackgroundColor,
  Ja as mainButtonHasShineEffect,
  tn as mainButtonState,
  Za as mainButtonText,
  Xa as mainButtonTextColor,
  Ic as mergeClassNames,
  zc as miniApp,
  ge as miniAppBackgroundColor,
  we as miniAppBottomBarColor,
  sn as miniAppBottomBarColorRGB,
  ye as miniAppHeaderColor,
  Fr as miniAppHeaderColorRGB,
  gi as miniAppReady,
  Wr as miniAppState,
  xc as mockTelegramEnv,
  Us as mountBackButton,
  sa as mountBiometry,
  la as mountClosingBehavior,
  ni as mountMainButton,
  bi as mountMiniApp,
  qi as mountSecondaryButton,
  Gi as mountSettingsButton,
  nc as mountSwipeBehavior,
  qr as mountThemeParams,
  mc as mountViewport,
  O as off,
  Ws as offBackButtonClick,
  oi as offMainButtonClick,
  Ui as offSecondaryButtonClick,
  Yi as offSettingsButtonClick,
  S as on,
  Fs as onBackButtonClick,
  ri as onMainButtonClick,
  $i as onSecondaryButtonClick,
  Ji as onSettingsButtonClick,
  ra as openBiometrySettings,
  Ma as openInvoice,
  ou as openLink,
  vi as openPopup,
  Ti as openQrScanner,
  Cc as openTelegramLink,
  Fc as parseInitData,
  ii as parseThemeParams,
  Gc as popup,
  Vt as postEvent,
  Jc as qrScanner,
  uu as readTextFromClipboard,
  Ss as removeEventHandlers,
  Nt as request,
  Ys as requestBiometry,
  oa as requestBiometryAccess,
  au as requestContact,
  dc as requestContentSafeAreaInsets,
  tu as requestEmojiStatusAccess,
  Sc as requestEmojiStatusAccessError,
  vo as requestEmojiStatusAccessPromise,
  uc as requestFullscreen,
  Bc as requestPhoneAccess,
  fc as requestSafeAreaInsets,
  _c as requestViewport,
  iu as requestWriteAccess,
  Ia as restoreInitData,
  J as retrieveLaunchParams,
  fu as safeCall,
  Yc as secondaryButton,
  Ii as secondaryButtonBackgroundColor,
  ki as secondaryButtonHasShineEffect,
  Mi as secondaryButtonPosition,
  ln as secondaryButtonState,
  ji as secondaryButtonText,
  Li as secondaryButtonTextColor,
  pu as sendData,
  Tc as serializeLaunchParams,
  vn as serializeThemeParams,
  ga as setCloudStorageItem,
  Mt as setCssVar,
  ru as setEmojiStatus,
  Ec as setEmojiStatusError,
  Ao as setEmojiStatusPromise,
  si as setMainButtonParams,
  zr as setMiniAppBackgroundColor,
  Gr as setMiniAppBottomBarColor,
  Jr as setMiniAppHeaderColor,
  Fi as setSecondaryButtonParams,
  Qc as settingsButton,
  lu as shareStory,
  su as shareURL,
  Hs as showBackButton,
  Qi as showSettingsButton,
  Mc as subscribe,
  G as supports,
  Kc as swipeBehavior,
  du as switchInlineQuery,
  Zc as themeParams,
  ja as themeParamsAccentTextColor,
  Xt as themeParamsBackgroundColor,
  Lr as themeParamsBottomBarBgColor,
  en as themeParamsButtonColor,
  jr as themeParamsButtonTextColor,
  La as themeParamsDestructiveTextColor,
  Va as themeParamsHeaderBackgroundColor,
  Na as themeParamsHintColor,
  $a as themeParamsLinkColor,
  Ue as themeParamsSecondaryBackgroundColor,
  Ua as themeParamsSectionBackgroundColor,
  Fa as themeParamsSectionHeaderTextColor,
  Wa as themeParamsSectionSeparatorColor,
  U as themeParamsState,
  Ha as themeParamsSubtitleTextColor,
  za as themeParamsTextColor,
  Qn as toRGB,
  Jn as toRecord,
  zs as unmountBackButton,
  aa as unmountBiometry,
  da as unmountClosingBehavior,
  ai as unmountMainButton,
  wi as unmountMiniApp,
  Wi as unmountSecondaryButton,
  Ki as unmountSettingsButton,
  rc as unmountSwipeBehavior,
  li as unmountThemeParams,
  hc as unmountViewport,
  jc as unsubscribe,
  ia as updateBiometryToken,
  mu as useLaunchParams,
  hu as useSignal,
  Xc as viewport,
  _o as viewportContentSafeAreaInsetBottom,
  mo as viewportContentSafeAreaInsetLeft,
  ho as viewportContentSafeAreaInsetRight,
  bo as viewportContentSafeAreaInsetTop,
  wn as viewportContentSafeAreaInsets,
  yn as viewportHeight,
  ao as viewportMountError,
  ut as viewportMountPromise,
  uo as viewportSafeAreaInsetBottom,
  po as viewportSafeAreaInsetLeft,
  lo as viewportSafeAreaInsetRight,
  fo as viewportSafeAreaInsetTop,
  gn as viewportSafeAreaInsets,
  Sn as viewportStableHeight,
  le as viewportState,
  Eo as viewportWidth
};
//# sourceMappingURL=index.js.map
